program(0,1) -> compile -> object
바이너리(이진수) = 0,1

어셈블리어는 기계어와 1:1 치환 됨
(개옛날)

C언어를 어셈블리로 바꾸는게 컴파일러?
소스코드를 바꾼다가 맞다.

소스코드란? 코드는 기호. 
프로그래머는 O언어를 이용해 소스코드를 만듬
이 소스코드는 C언어 문법에 맞춰 적힌 일련의 기호임.
컴파일러도 번역할 수 있기에 의미를 알고 있음.
이 의미를 순서대로 기계가 번역할 수 있게 나열하게 해줌
이 컴파일의 결과물이 object 파일임

이 소스에 대해 번역(컴파일)된 바이너리 파일 => object

헤더 파일이 굉장히 많으면 옵젝 파일이 많아짐
하나하나 다 실행할 수 없기 때문에 여러개 목적을 가진
코드들을 융합, 응용해서 실행하는 작업을 링킹이라고 함.

링킹을 하면 여러 옵젝 파일을 묶어 실행 가능하게 해줌.
실행 파일이 나옴(윈도우는 .exe/리눅스는 binary 파일 등)
실행하면 윈도우에서 메인함수를 불러주고 끝냄
메인함수가 끝나면 프로그램이 종료되는 원리

코드 각각 옵젝 링킹한번 하면 시험 준비 끝


------------------------------------------------------------

function 함수
 y=f(x)     int func(int x) { return y; } 즉, y=fx가 되는것 

#include <stdio.h> or ".h" <- 모듈을 불러오는 역할
인클루드라는 명령어로 헤더파일을 읽게끔 함
저 stdio.h 안에 사용 가능한 것들이 저장되어 있으며 그걸
가져다 편하게 사용할 수 있게 하는 것
<> : 단순 파일명
"" : 문자열
< > ( ) { } " " ' '
if/else if
while
int 
char

a=96은 96이란 숫자를 입력하면 a로 인식해달라
알파벳을 표현하는데에 (약 70*대/소2)에 \n /t 같은
특수기호 전부를 저장하려면 char 안에 들어가야할 갯수가
128개가 넘어감.  그래서 char 기본형이 8비트(1바이트)
256개라서 기호, 문자 다 들어감 %c (문자) %d (숫자)

= <- 오른쪽에 있는 걸 왼쪽에다 대입하겠다
ex) a=2 <- 2를 a에 넣겠다.
== <- 같을 때, 참이라고 하겠다. (1 이상의 숫자, 거짓 0)
int 0 <- 32개의 0으로 되어있음 

| || & && << >>  
if(A 10 & B 01) 
&& => a랑b가 둘다 참이어야 함

<< >> 시프트 

a<<3 => a를 3만큼 밀어넣는다.

>>1 이면은 이게 
<<